/*
 * tbl (.TS / .TE) support.
 *
 * this only supports the tbl subset generated by mancdoc -Tman
 *
 * options: no.
 * formatting: one line only, l/c/r only (mandoc only uses l)
 * data: one-line only, tab separated
 * max 8 columns
 * .PP commands may be intermixed and are ignored.
 */

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "man.h"


#define MAX_COLS 8
static unsigned column_width[8];
static unsigned column_align[8];

// lines are buffered so we can calculate column widths. 
// the original tbl itself would only use the first 200 lines, IIRC
char **lines;
unsigned lines_length;
unsigned lines_capacity;


#define SPECIAL_DASH (unsigned char *)1
#define SPECIAL_BLANK (unsigned char *)2


enum {
	align_left,
	align_right,
	align_center
};


extern unsigned xstrlen(const unsigned char *cp);
extern unsigned xstrnlen(const unsigned char *cp, unsigned max);
extern unsigned print(const unsigned char *cp, int fi);

static char buffer[512]; // todo -- share w/ render.c

#if 0
unsigned unformatted_length(char *cp, unsigned start, unsigned end) {
	unsigned l = 0;
	while (start < end) {
		unsigned c = cp[start++];
		if (c <= XSPACE) ++l;
	}
	return l;
}
#endif

void tbl(void) {


	int cols = 0;
	unsigned st = 0;
	unsigned e_flag = 0;
	unsigned e_width = 0;

	memset(column_width, 0, sizeof(column_width));
	memset(column_align, 0, sizeof(column_align));

	lines = NULL;
	lines_capacity = 0;
	lines_length = 0;


	lines = malloc(sizeof(char *) * 64);
	if (!lines) man_err(1,"malloc");
	lines_capacity = 64;

	for(;;) {
		const unsigned char *cp = read_text();
		if (type == tkEOF) {
			man_warnx("TS without TE");
			break;
		}

		if (type == tkTE) break;
		if (type == tkPP) continue;
		if (type != tkTEXT) {
			man_warnx1s("unsupported %s within tbl", token_names[type]);
			break;
		}

		// text!
		unsigned x = strlen(cp);
		if (!x) continue;

		if (st == 0) {
			// (optional) option string (;-terminated)
			++st;
			if (cp[x-1] == ';') continue;
		}

		if (st == 1) {

			// 1+ format strings, final one is '.' terminated.
			// currently, only one line is supported and only alignment is supported

			// todo:
			// w(num) which will pre-populate the column_width
			// e - (equal width) set a bit on the equal flag,
			// after calculating column widths, set all e columns to the max of all e columns.


			// format string.  currently just alignment...
			cols = -1;
			for (unsigned i = 0; ;++i) {
				unsigned c = cp[i];
				if (c == 0) break;
				c = tolower(c);

				if (c == ',') {
					// multiple formats on one line.
					cols = -1;
					continue;
				}

				if (c == '.') {
					++st;
					++cols;
					if (cols < 1) {
						cols = 1;
						column_align[0] = align_left;
					}
					if (cols >= MAX_COLS) cols = MAX_COLS - 1;
					break;
				}
				if (c == 'l' || c == 'r' || c == 'c' || c == 'n' || c == 'a') {
					++cols;
				}
				if (cols < 0 || cols >= MAX_COLS) continue;

				switch(c) {
				case 'l':
				case 'a': // alphabetic subcolumn
					column_align[cols] = align_left;
					break;
				case 'r':
				case 'n': // numeric
					column_align[cols] = align_right;
					break;
				case 'c': 
					column_align[cols] = align_center;
					break;

				case 'e':
					e_flag |= (1 << cols);
					break;

				}
				// silently ignore everything else....
			}

			continue;
		}


		if (lines_length == lines_capacity) {
			char **tmp = realloc(lines, lines_capacity << 1);
			if (!tmp) man_err(1, "realloc");
			lines = tmp;
			lines_capacity <<= 1;
		}

		// a line of data...
		// count the columns...
		unsigned nc = 1;
		unsigned l = 0;
		for (l = 0; ; ++l) {
			unsigned c = cp[l];
			if (!c) break;
			if (c == '\t') ++nc;
		}

		if (!l) {
			lines[lines_length++] = SPECIAL_BLANK;
			continue;
		}

		// todo: '-', '=' just draw a line.
		if (l == 1) {
			if (cp[0] == '_' || cp[0] == '=') {
				lines[lines_length++] = SPECIAL_DASH;
				continue;
			}
		}

		if (nc > cols) nc = cols;

		// each chunk has 1 byte length, 1 byte length w/o formatting.
		char *line = malloc(l + cols * 2 + 2);
		if (!line) man_err(1, "malloc");
		memset(line, 0, l + cols * 2 + 2);
		lines[lines_length++] = line;

		for (unsigned i = 0, j = 0, col = 0, mask = 1; col < nc; ++col, mask <<= 1) {

			unsigned st = i;
			unsigned c;

			for (;;) { c = cp[i++]; if (c == '\t' || c == 0) break; }
			unsigned end = i - 1;

			line[j++] = end - st; // total length

			unsigned x = xstrnlen(cp + st, end - st);
			if (x > column_width[col]) column_width[col] = x;

			if (e_flag & mask) {
				if (x > e_width) e_width = x;
			}

			line[j++] = x;
			while (st < end) line[j++] = cp[st++];
		}

		// todo -- only first N lines to calc width?

	}

	// resize e columns?
	if (e_flag) {
		for (unsigned col = 0, mask = 1; col < cols; ++col, mask <<= 1) {
			if (e_flag & mask) column_width[col] = e_width;
		}
	}


	// calculate the total width (for _)
	unsigned twidth = -3; // account for extra padding
	for (unsigned i = 0, mask = 1; i < cols; ++i, mask <<= 1) {

		if (e_flag & mask) {
			column_width[i] = e_width;
			twidth += e_width;
		} else {
			twidth += column_width[i];
		}
		twidth += 3;
	}

	// now print the buffered table...

	for (unsigned i = 0; i < lines_length; ++i) {
		unsigned char *line = lines[i];


		if (line == SPECIAL_BLANK) {
			fputc('\n', stdout);
			continue;
		}
		if (line == SPECIAL_DASH) {
			for (unsigned j = 0; j < in; ++j) fputc(' ', stdout);
			for (unsigned j = 0; j < twidth; ++j)
				fputc('_', stdout);
			fputc('\n', stdout);
			continue;
		}

		unsigned padding = 0;
		unsigned k = 0;
		for (unsigned col = 0, offset = 0; col < cols; ++col) {
			unsigned w = column_width[col];
			unsigned align = column_align[col];

			unsigned ll = line[offset++]; // width w/ formatting
			unsigned l = line[offset++]; // printable width

			unsigned sp = w > l ? w - l : 0;

			switch(align) {
			default:
			case align_left:
				break;
			case align_right:
				padding += sp;
				sp = 0;
				break;
			case align_center:
				padding += sp >> 1;
				sp = (sp+1) >> 1;
				break;
			}

			for (unsigned i = 0; i < padding; ++i) {
				buffer[k++] = ' ';
			}

			for(unsigned i = 0; i < ll; ++i) {
				buffer[k++] = line[offset++];
			}

			padding = sp + 3; // 3 spaces of padding between columns + alignment.
		}


		buffer[k++] = '\n';
		buffer[k++] = 0;
		print(buffer, 0);

		free(line);
	}

	
	free(lines);
}
