/*
 * tbl (.TS / .TE) support.
 *
 * this only supports the tbl subset generated by mancdoc -Tman
 *
 * options: no.
 * formatting: one line only, l/c/r only (mandoc only uses l)
 * data: one-line only, tab separated
 * max 8 columns
 * .PP commands may be intermixed and are ignored.
 */

#define MAX_COLS 8
static unsigned column_width[8];
static unsigned column_align[8];

// lines are buffered so we can calculate column widths. 
// the original tbl itself would only use the first 200 lines, IIRC
char **lines;
unsigned lines_length;
unsigned lines_capacity;


// body
// read a line, copy to new buffer

// byte length, byte length w/o format codes, text ... 


for (unsigned col = 0, i = 0; ; ++col) {
	unsigned l = cp[i++];
	if (!l) break;

	unsigned ll = cp[i++];

	if (ll > column_width[col]) column_width[col] = ll;
	i += l;
}


// now render....

for (unsigned col = 0, i = 0; ; ++col) {

	unsigned l = cp[i++];
	if (!l) break;

	unsigned ll = cp[i++];

	unsigned padding = 0;
	if (col > 0) padding = 3;

	unsigned w = column_width[col];
	unsigned sp = w > ll ? w - ll : 0;
	unsigned align = column_align[col];


	switch (align) {
	case align_left: break;
	case align_center:
		padding += sp >> 1;
		sp = (sp + 1) >> 1;
		break;
	case align_right:
		padding = sp;
		sp = 0;
		break;
	}

	// print the padding. 
	// print the text...
	padding = sp;
	if (sp) // print sp padding.
}


unsigned unformatted_length(char *cp, unsigned start, unsigned end) {
	unsigned l = 0;
	while (start < end) {
		unsigned c = cp[start++];
		if (c <= XSPACE) ++l;
	}
	return l;
}

void tbl(void) {


	int cols = 0;
	unsigned st = 0;
	unsigned flag_e = 0;
	unsigned max_e = 0;

	memset(column_width, 0, sizeof(column_width));
	memset(column_align, 0, sizeof(column_align));

	for(;;) {
		int x;
		const unsigned char *cp = read_text();
		if (type == tkEOF) {
			man_warnx1("TS without TE");
			break;
		}

		if (type == tkTE) break;
		if (type == tkPP) continue;
		if (type != tkTEXT) {
			man_warnx1("unsupported command within tbl");
			break;
		}

		// text!
		unsigned x = strlen(cp);
		if (!x) continue;

		if (st == 0) {
			// possible (optional) option string (;-terminated)
			++st;
			if (cp[x-1] == ';') continue;
		}
		if (st == 1) {

			// 1+ format strings, final one is '.' terminated.
			// currently, only one line is supported and only alignment is supported

			// todo:
			// w(num) which will pre-populate the column_width
			// e - (equal width) set a bit on the equal flag,
			// after calculating column widths, set all e columns to the max of all e columns.


			// format string.  currently just alignment...
			cols = -1;
			for (unsigned i = 0; ;++i) {
				unsigned c = cp[i];
				if (c == 0) break;
				c = tolower(c);
				if (c == '.') {
					++st;
					if (cols < 1) {
						cols = 1;
						column_align[0] = align_left;
					}
					break;
				}
				if (c == 'l' || c == 'r' || c == 'c' || c == 'n' || c == 'a') {
					++cols;
				}
				if (cols < 0 || cols >= MAX_COLS) continue;

				// if (cols == MAX_COLS) continue;
				switch(c) {
				case 'l':
				case 'a': // alphabetic subcolumn
					column_align[cols] = align_left;
					break;
				case 'r':
				case 'n': // numeric
					column_align[cols] = align_right;
					break;
				case 'c': 
					column_align[cols] = align_center;
					break;

				case 'e':
					flag_e |= (1 << cols);
					break;

				}
				// silently ignore everything else....
			}

			continue;
		}


		// a line of data...
		// count the columns...
		unsigned nc = 1;
		unsigned l = 0;
		for (l = 0; ; ++l) {
			unsigned c = cp[l];
			if (!c) break;
			if (c == '\t') ++nc;
		}

		if (nc > MAX_COLS) nc = MAX_COLS;
		// each chunk has 1 byte length, 1 byte length w/o formatting.
		char *line = malloc(l + nc * 2 + 2);
		for (unsigned i = 0, j = 0, col = 0; col < nc; ++col) {

			unsigned st = i;
			unsigned c;

			for (;;) { c = cp[i++]; if (c == '\t' || c == 0) break; }
			unsigned end = i;

			line[j++] = end - st; // total length

			unsigned x = unformatted_length(cp, st, end);
			if (x > column_width[col]) column_width[col] = x;

			if (flag_e & (1 << col)) {
				if (x > max_e) max_e = x;
			}

			line[j++] = x;
			while (st < end) line[j++] = cp[st++];
			line[j] = 0; // zero out the final entry
		}

		// todo -- only first N lines to calc width?

	}

	// resize e columns?
	if (flag_e) {
		for (unsigned col = 0, mask = 1; col < MAX_COLS; ++col, mask <<= 1) {
			if (flag_e & mask) column_width[col] = max_e;
		}
	}


	// now print the buffered table...

	for (unsigned i = 0; i < line_count; ++i) {
		unsigned char *line = lines[i];

		unsigned k = 0;

		unsigned padding = in;
		unsigned k = 0;
		for (unsigned col = 0, offset = 0; col < cols; ++col) {
			unsigned w = column_width[col];
			unsigned align = column_align[col];

			unsigned ll = line[offset++]; // width w/ formatting
			unsigned l = line[offset++]; // printable width

			unsigned sp = w > l ? w - l : 0;

			switch(align) {
			case align_left:
				break;
			case align_right:
				padding += sp;
				sp = 0;
				break;
			case align_center:
				padding += sp >> 1;
				sp = (sp+1) >> 1;
				break;
			}

			for (unsigned i = 0; i < padding; ++i) {
				buffer[k++] = ' ';
			}

			for(unsigned i = 0; i < ll; ++i) {
				buffer[k++] = line[offset++];
			}

			padding = sp + 3; // 3 spaces of padding between columns + alignment.
		}


		buffer[k++] = 0;
		print(buffer, 0);

		free(line);
	}

	
	free(lines);
}
